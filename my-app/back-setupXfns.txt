****UNIT OF WORK****

builder.Services.AddScoped<IUnitOfWork, UnitOfWork>();

>INFRASTRUCTURE>:
 -UnitOfWork:
public class UnitOfWork : IUnitOfWork
{
    private readonly AppDbContext _dbContext;
    public IXXRepository XXs { get; private set; }

    public UnitOfWork(AppDbContext dbContext)
    {
        _dbContext = dbContext;
        XXs = new XXRepository(_dbContext);
    }

    public Task<int> CompleteAsync()
    {
        return _dbContext.SaveChangesAsync();
    }

    public void Dispose()
    {
        _dbContext.Dispose();
    }
}


>DOMAIN>INTERFACES:
 -IUnitOfWork:
public interface IUnitOfWork : IDisposable
{
    IXXRepository XXs { get; }
    Task<int> CompleteAsync();
}


>INFRASTRUCTURE>Repos:
 -GenericRepository:
public abstract class GenericRepository<T> : IGenericRepository<T> where T : class
{
    protected readonly AppDbContext _dbContext;
    private bool _disposed = false;

    protected GenericRepository(AppDbContext dbContext)
    {
        _dbContext = dbContext;
    }

    public async Task<List<T>> GetAllAsync()
    {
        return await _dbContext.Set<T>().ToListAsync();
    }

    public async Task<T?> GetOneAsync(int id)
    {
        return await _dbContext.Set<T>().FindAsync(id);
    }

    public async Task<T> AddAsync(T entity)
    {
        await _dbContext.Set<T>().AddAsync(entity);
        return entity;
    }
    public void Update(T entity)
    {
        _dbContext.Set<T>().Update(entity);
    }
    public void Delete(T entity)
    {
        _dbContext.Set<T>().Remove(entity);
    }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (!_disposed)
        {
            if (disposing)
            {
                _dbContext.Dispose();
            }

            _disposed = true;
        }
    }
}

>DOMAIN>INTERFACES:
 -IGenericRepository:
public interface IGenericRepository<T> where T : class
{
    Task<List<T>> GetAllAsync();
    Task<T?> GetOneAsync(int id);
    Task<T> AddAsync(T entity);
    void Update(T entity);
    void Delete(T entity);
    void Dispose();
}


==CONTROLLER:

private readonly IXXService _xyService;

public XXController(IXXService xyService)
{
    _xyService = xyService;
}

[HttpGet("filtered")]
public async Task<IActionResult> GetXXsFilteredAsync([FromQuery] XXFilterMix filters)
{
    var xys = await _xyService.GetAllFilteredAsync(filters);
    return Ok(xys);
}

[HttpGet]
public async Task<IActionResult> GetAllXXsAsync()
{
    var xys = await _xyService.GetAllAsync();
    return Ok(xys);
}

[HttpGet("{id}")]
public async Task<IActionResult> GetXXByIdAsync(int id)
{
    var xy = await _xyService.GetOneAsync(id);
    return Ok(xy);
}

[HttpPost]
public async Task<IActionResult> CreateXX([FromBody] XXDto xy)
{
    await _xyService.CreateAsync(xy);
    return Ok(xy);
}

[HttpPut]
public async Task<IActionResult> UpdateXX([FromBody] XXDto xy)
{
    await _xyService.UpdateAsync(xy);
    return Ok();
}

[HttpDelete("{id}")]
public async Task<IActionResult> DeleteXX(int id)
{
    await _xyService.DeleteAsync(id);
    return NoContent();
}

==SERVICE:

private readonly IUnitOfWork _unitOfWork;
private readonly IMapper _mapper;

public XXService(IUnitOfWork unitOfWork, IMapper mapper)
{
    _unitOfWork = unitOfWork;
    _mapper = mapper;
}

public async Task<List<XXDto>> GetAllFilteredAsync(int sort, XXFilterMix filters)
{
    return _mapper.Map<List<XXDto>>(await _unitOfWork.XXs.GetAllFilteredAsync(filters));
}

public async Task<List<XXDto>> GetAllAsync()
{
    return _mapper.Map<List<XXDto>>(await _unitOfWork.XXs.GetAllAsync());
}

public async Task<XXDto?> GetOneAsync(int id)
{
    var xy = await _unitOfWork.XXs.GetOneAsync(id);
    if (xy == null)
    {
        throw new NotFoundException(id);
    }
    return _mapper.Map<XXDto>(xy);
}

public async Task CreateAsync(XXDto xyDto)
{
    var xy = _mapper.Map<XX>(xyDto);
    await _unitOfWork.XXs.AddAsync(xy);
    await _unitOfWork.CompleteAsync();
}

public async Task UpdateAsync(XXDto xyDto)
{
    var xy = await _unitOfWork.XXs.GetOneAsync(xyDto.Id);
    if (xy == null)
    {
        throw new NotFoundException(xyDto.Id);
    }
    _mapper.Map(xyDto, xy);
    _unitOfWork.XXs.Update(xy);
    await _unitOfWork.CompleteAsync();
}

public async Task DeleteAsync(int id)
{
    var xy = await _unitOfWork.XXs.GetOneAsync(id);
    if (xy == null)
    {
        throw new NotFoundException(id);
    }
    _unitOfWork.XXs.Delete(xy);
    await _unitOfWork.CompleteAsync();
}

-Service Interface:
  Task<List<XXDto>> GetAllFilteredAsync(int sort, XXFilterMix filters);
  Task<List<XXDto>> GetAllAsync();
  Task<XXDto?> GetOneAsync(int id);
  Task CreateAsync(XXDto xyDto);
  Task UpdateAsync(XXDto xyDto);
  Task DeleteAsync(int id);

==REPOSITORY:
-Interface looks: public interface IXXRepository : IGenericRepository<XX>


public class XXRepository : GenericRepository<XX>, IXXRepository
{
    public XXRepository(AppDbContext _dbContext) : base(_dbContext)
    {
    }
}

public new async Task<List<XX>> GetAllAsync()
{
    return await _dbContext.XXs
        .Include(a => a.YY)
        .Include(a => a.ZZ)
        .ToListAsync();
}

public async Task<List<XX>> GetAllFilteredAsync(XXFilterMix filters, int sort)
{
    var query = _dbContext.XXs
        .Include(a => a.YY)
        .Include(a => a.ZZ)
        .AsQueryable();

    query = ApplyFilters(query, filters);
    query = ApplySorting(query, sort);

    return await query.ToListAsync();
}

public new async Task<XX?> GetOneAsync(int id)
{
    return await _dbContext.XXs
        .Include(a => a.ZZ)
        .Include(a => a.YY)
        .FirstOrDefaultAsync(o => o.Id == id);
}

public IQueryable<XX> ApplyFilters(IQueryable<XX> query, XXFilterMix filters)
{
    if (!string.IsNullOrEmpty(filters.Species))
    {
        query = query.Where(a => a.YY.Name.Contains(filters.YYName));
    }

    if (filters.CagelessOnly)
    {
        query = query.Where(a => a.Cage == null);
    }

    if (filters.ExpiresAt)
    {
        query = query.Where(a => a.ExpiresAt)
    }

    if (filters.MinPrice.HasValue && filters.MaxPrice.HasValue)
    {
        query = query.Where(a => a.Price >= filters.MinPrice.Value && a.Price <= filters.MaxPrice.Value);
    }

    if (filters.AgeFrom.HasValue && filters.AgeTo.HasValue)
    {
        query = query.Where(a => a.Birthday.AddYears(filters.AgeFrom.Value) <= DateTime.UtcNow && a.Birthday.AddYears(filters.AgeTo.Value) >= DateTime.UtcNow);
    }

    return query;
}


private IQueryable<XX> ApplySorting(IQueryable<XX> query, string sort)
{
    if (!Enum.TryParse<XXSortTypes>(sort, true, out var sortType))
        sortType = XXSortTypes.NAME_ASC;

    return sortType switch
    {
        XXSortTypes.NAME_DESC => query.OrderByDescending(d => d.Name),
        XXSortTypes.TYPE_ASC => query.OrderBy(d => d.Type),
        XXSortTypes.TYPE_DESC => query.OrderByDescending(d => d.Type),
        XXSortTypes.PRICE_ASC => query.OrderBy(d => d.Price),
        XXSortTypes.PRICE_DESC => query.OrderByDescending(d => d.Price),
        _ => query.OrderBy(d => d.Name)
    };
}

// ------MAPPER------

.ForMember(dest => dest.ExpirationDate, opt => opt.MapFrom(src => DateTime.SpecifyKind(src.ExpirationDate, DateTimeKind.Utc)));

.ForMember(dest => dest.CreatedAt, opt => opt.MapFrom(_ => DateTime.UtcNow))

.ForMember(dest => dest.OfferId, opt =>
  {
    opt.Condition(src => src.ItemType == "OFFER");
    opt.MapFrom(src => src.Id);
  });

CreateMap<XX, XXDto>()
    .ReverseMap()
    .ForMember(dest => dest.Id, opt => opt.Ignore());








___________________________________________
-=*-=*-=*-=*-=FROM 0 SETUP=-*=-*=-*=-*=-
___________________________________________

------EFC------

Microsoft.EntityFrameworkCore
Microsoft.EntityFrameworkCore.Tools
Npgsql.EntityFrameworkCore.PostgreSQL

builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseNpgsql(builder.Configuration.GetConnectionString("DefaultConnection")));

"ConnectionStrings": {
    "DefaultConnection": "Host=localhost;Port=5432;Database=cinemaDb;Username=postgres;Password=root"
  }

builder.Services.AddScoped<EntityService>();
builder.Services.AddScoped<IEntityRepository, EntityRepository>();

builder.Services.AddAutoMapper(typeof(MappingProfile));
builder.Services.AddTransient<ExceptionHandlingMiddleware>();


app.UseMiddleware<ExceptionHandlingMiddleware>();


_IDENTITY_

Microsoft.AspNetCore.Identity.EntityFrameworkCore biblioteka

public class ApplicationUser : IdentityUser

public class AppDbContext : IdentityDbContext<ApplicationUser>

// ...
// Registracija Identity-a
builder.Services.AddIdentity<ApplicationUser, IdentityRole>()
  .AddEntityFrameworkStores<AppDbContext>()
  .AddDefaultTokenProviders();

// Definisanje uslova koje lozinka mora da ispuni
builder.Services.Configure<IdentityOptions>(options =>
{
  options.Password.RequireDigit = true;          // Ima bar jednu cifru
  options.Password.RequireLowercase = true;      // Ima bar jedno malo slovo
  options.Password.RequireUppercase = true;      // Ima bar jedno veliko slovo
  options.Password.RequireNonAlphanumeric = true;// Ima bar jedan specijalan karakter (!, @, #...)
  options.Password.RequiredLength = 8;           // Ima bar 8 karaktera
});

// Dodavanje autentifikacije
builder.Services.AddAuthentication();
// ...
var app = builder.Build();

// Uključivanje autentifikacije
app.UseAuthentication();


_MIDDLEWARE_

internal sealed class ExceptionHandlingMiddleware : IMiddleware
{
  public ExceptionHandlingMiddleware() {}

  public async Task InvokeAsync(HttpContext context, RequestDelegate next)
  {
    try
    {
      await next(context);
    }
    catch (Exception e)
    {
      await HandleExceptionAsync(context, e);
    }
  }

  private async Task HandleExceptionAsync(HttpContext httpContext, Exception exception)
  {
    httpContext.Response.ContentType = "application/json";
    httpContext.Response.StatusCode = exception switch
    {
      BadRequestException => StatusCodes.Status400BadRequest,
      ForbiddenException => StatusCodes.Status403Forbidden,
      NotFoundException => StatusCodes.Status404NotFound,
      _ => StatusCodes.Status500InternalServerError
    };
    var response = new { error = exception.Message };
    await httpContext.Response.WriteAsync(JsonSerializer.Serialize(response));
  }
}

_JWT_

Microsoft.AspNetCore.Authentication.JwtBearer

"Jwt": {
    "Key": "w31AjQ14HDyfea6R5W0hsZJ6B8bd/5st9J05M19Lcno=",
    "Issuer": "http://localhost:5231",
    "Audience": "http://localhost:5231"
  }

builder.Services.AddAuthentication();

builder.Services.AddAuthentication(options =>
{ // Naglašavamo da koristimo JWT
  options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
  options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
})
.AddJwtBearer(options =>
{
  options.TokenValidationParameters = new TokenValidationParameters
  {
    ValidateLifetime = true, // Validacija da li je token istekao

    ValidateIssuer = true,   // Validacija URL-a aplikacije koja izdaje token
    ValidIssuer = builder.Configuration["Jwt:Issuer"], // URL aplikacije koja izdaje token (čita se iz appsettings.json)

    ValidateAudience = true, // Validacija URL-a aplikacije koja koristi token
    ValidAudience = builder.Configuration["Jwt:Audience"], // URL aplikacije koja koristi token (čita se iz appsettings.json)

    ValidateIssuerSigningKey = true, // Validacija ključa za potpisivanje tokena (koji se koristi i pri proveri potpisa)
    IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(builder.Configuration["Jwt:Key"])), //Ključ za proveru tokena (čita se iz appsettings.json)

    RoleClaimType = ClaimTypes.Role // Potrebno za kontrolu pristupa, što ćemo videti kasnije
  };
});